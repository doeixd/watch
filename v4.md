# Watch v4: Elegant DOM Observation

## Philosophy

Watch v4 combines battle-tested DOM observation with modern API design. The core principle is **progressive enhancement**: start with simple direct calls, compose with generators when needed.

### Design Principles

1. **Primitive-First**: Core functions are simple, composable primitives
2. **Dual API**: Every function works both directly and in generators
3. **Type Safety**: Comprehensive TypeScript without complexity
4. **Performance**: Battle-tested observer patterns with modern optimizations
5. **Zero Dependencies**: Pure DOM APIs with intelligent fallbacks

## Core Architecture

```typescript
// Primitive building blocks
type WatchSubject = string | HTMLElement | ((el: HTMLElement) => boolean);
type WatchFn<T extends HTMLElement = HTMLElement> = (instance: WatchedInstance<T>) => void;

interface WatchedInstance<T extends HTMLElement = HTMLElement> {
  element: T;
  state: Record<string, any>;
}

// The core watch function
function watch<T extends HTMLElement = HTMLElement>(
  subject: WatchSubject,
  fn?: WatchFn<T>,
  parent?: HTMLElement
): WatchConfig<T>;
```

## The Dual API Pattern

Every helper function follows the **overloaded pattern**:

```typescript
// Direct usage - immediate effect
text(element, 'Hello World');
addClass(element, 'active');
style(element, 'color', 'red');

// Generator usage - returns function for composition
const setup = function*() {
  yield text('Hello World');
  yield addClass('active');
  yield style('color', 'red');
};

watch('.button', setup);
```

## Core Primitives

### DOM Manipulation

```typescript
// Text content
function text(el: ElementLike, content: string): void;
function text(content: string): (instance: WatchedInstance) => void;

// HTML content
function html(el: ElementLike, content: string): void;
function html(content: string): (instance: WatchedInstance) => void;

// Attributes
function attr(el: ElementLike, name: string, value: string): void;
function attr(name: string, value: string): (instance: WatchedInstance) => void;

// Classes
function addClass(el: ElementLike, className: string): void;
function addClass(className: string): (instance: WatchedInstance) => void;

function removeClass(el: ElementLike, className: string): void;
function removeClass(className: string): (instance: WatchedInstance) => void;

function toggleClass(el: ElementLike, className: string, force?: boolean): void;
function toggleClass(className: string, force?: boolean): (instance: WatchedInstance) => void;

// Styles
function style(el: ElementLike, prop: string, value: string): void;
function style(prop: string, value: string): (instance: WatchedInstance) => void;

// Properties
function prop(el: ElementLike, name: string, value: any): void;
function prop(name: string, value: any): (instance: WatchedInstance) => void;

// Data attributes
function data(el: ElementLike, key: string, value: string): void;
function data(key: string, value: string): (instance: WatchedInstance) => void;
```

### Selection

```typescript
// Query single element
function el<T extends HTMLElement = HTMLElement>(parent: ElementLike, selector: string): T | null;
function el<T extends HTMLElement = HTMLElement>(selector: string): (instance: WatchedInstance) => T | null;

// Query multiple elements
function els<T extends HTMLElement = HTMLElement>(parent: ElementLike, selector: string): T[];
function els<T extends HTMLElement = HTMLElement>(selector: string): (instance: WatchedInstance) => T[];

// Traversal
function parent<T extends HTMLElement = HTMLElement>(el: ElementLike, selector?: string): T | null;
function parent<T extends HTMLElement = HTMLElement>(selector?: string): (instance: WatchedInstance) => T | null;

function siblings<T extends HTMLElement = HTMLElement>(el: ElementLike, selector?: string): T[];
function siblings<T extends HTMLElement = HTMLElement>(selector?: string): (instance: WatchedInstance) => T[];
```

### State Management

```typescript
// Simple state operations
function state<T = any>(key: string, value: T): (instance: WatchedInstance) => void;
function state<T = any>(key: string): (instance: WatchedInstance) => T | undefined;

// State updates
function updateState<T = any>(key: string, updater: (current: T) => T): (instance: WatchedInstance) => void;

// Typed state helpers
function createState<T>(key: string, initialValue: T) {
  return {
    get: () => state<T>(key),
    set: (value: T) => state(key, value),
    update: (fn: (current: T) => T) => updateState(key, fn),
    init: () => state(key, initialValue)
  };
}
```

### Event Handling

```typescript
// Basic events
function on<K extends keyof HTMLElementEventMap>(
  el: ElementLike,
  event: K,
  handler: (event: HTMLElementEventMap[K]) => void
): () => void;

function on<K extends keyof HTMLElementEventMap>(
  event: K,
  handler: (event: HTMLElementEventMap[K], instance: WatchedInstance) => void
): (instance: WatchedInstance) => () => void;

// Advanced events (from original Watch)
function onAttr(filter: string | RegExp, handler: (mutation: MutationRecord) => void): (instance: WatchedInstance) => void;
function onText(handler: (newText: string, oldText: string) => void): (instance: WatchedInstance) => void;
function onVisible(handler: (isVisible: boolean) => void): (instance: WatchedInstance) => void;
function onResize(handler: (entry: ResizeObserverEntry) => void): (instance: WatchedInstance) => void;

// Lifecycle events
function onMount(handler: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;
function onUnmount(handler: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;
```

### Utilities

```typescript
// Timing
function delay(ms: number, fn: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;
function throttle(ms: number, fn: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;
function debounce(ms: number, fn: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;

// Execution control
function once(fn: (instance: WatchedInstance) => void): (instance: WatchedInstance) => void;
function when(
  condition: (instance: WatchedInstance) => boolean,
  then: (instance: WatchedInstance) => void,
  otherwise?: (instance: WatchedInstance) => void
): (instance: WatchedInstance) => void;

// Error handling
function safely<T>(
  fn: (instance: WatchedInstance) => T,
  fallback?: T
): (instance: WatchedInstance) => T | undefined;

// Animation
function animate(keyframes: Keyframe[], options?: KeyframeAnimationOptions): (instance: WatchedInstance) => Animation;
function fadeIn(duration?: number): (instance: WatchedInstance) => Animation;
function fadeOut(duration?: number): (instance: WatchedInstance) => Animation;
```

## Usage Patterns

### 1. Direct Usage (Immediate)

```typescript
// Simple DOM manipulation
const button = document.querySelector('.button');
text(button, 'Click me');
addClass(button, 'primary');
style(button, 'color', 'blue');

// Event handling
on(button, 'click', () => {
  console.log('Clicked!');
});
```

### 2. Generator Usage (Composable)

```typescript
// Simple interactive component
watch('.counter', function*() {
  const count = createState('count', 0);
  
  yield count.init();
  yield text(`Count: ${count.get()}`);
  
  yield on('click', (_, instance) => {
    count.update(c => c + 1);
    text(`Count: ${count.get()}`)(instance);
  });
});

// Complex component with lifecycle
watch('.modal', function*() {
  yield onMount((instance) => {
    addClass('modal-open')(instance);
    animate(fadeIn())(instance);
  });
  
  yield on('click', '.close', (_, instance) => {
    animate(fadeOut())(instance).finished.then(() => {
      removeClass('modal-open')(instance);
    });
  });
  
  yield onUnmount((instance) => {
    removeClass('modal-open')(instance);
  });
});
```

### 3. Wrapper-Enhanced Usage

```typescript
// Create reusable behaviors
const withClickCounter = createWrapper((instance) => {
  const count = createState('count', 0);
  
  return {
    ...instance,
    incrementCount: () => {
      count.update(c => c + 1);
      text(`Count: ${count.get()}`)(instance);
    }
  };
});

// Use wrapper
watch('.button', withClickCounter(function*() {
  yield on('click', (_, instance) => {
    instance.incrementCount();
  });
}));
```

### 4. Form Handling

```typescript
// Form validation
watch('input[required]', function*() {
  const validate = (value: string) => value.length > 0;
  
  yield on('input', (event, instance) => {
    const input = event.target as HTMLInputElement;
    const isValid = validate(input.value);
    
    toggleClass('invalid', !isValid)(instance);
    
    if (!isValid) {
      attr('aria-describedby', 'error-message')(instance);
    } else {
      attr('aria-describedby', '')(instance);
    }
  });
});

// Form submission
watch('form', function*() {
  yield on('submit', (event, instance) => {
    event.preventDefault();
    
    const formData = new FormData(event.target as HTMLFormElement);
    const isValid = els('input[required]', instance.element).every(input => 
      input.value.trim().length > 0
    );
    
    if (isValid) {
      addClass('loading')(instance);
      // Submit form
    } else {
      addClass('error')(instance);
      animate(shake())(instance);
    }
  });
});
```

## Advanced Features

### Observer Integration

```typescript
// Intersection Observer
watch('.lazy-image', function*() {
  yield onVisible((isVisible, instance) => {
    if (isVisible) {
      const src = data('src')(instance);
      attr('src', src)(instance);
      removeClass('lazy')(instance);
    }
  });
});

// Resize Observer
watch('.responsive-chart', function*() {
  yield onResize((entry, instance) => {
    const width = entry.contentRect.width;
    style('--chart-width', `${width}px`)(instance);
  });
});
```

### Performance Optimizations

```typescript
// Throttled scroll handling
watch('.parallax-element', function*() {
  yield throttle(16, (instance) => {
    const scrollY = window.scrollY;
    const offset = scrollY * 0.5;
    style('transform', `translateY(${offset}px)`)(instance);
  });
});

// Debounced search
watch('.search-input', function*() {
  yield debounce(300, (instance) => {
    const query = (instance.element as HTMLInputElement).value;
    performSearch(query);
  });
});
```

### State Management Patterns

```typescript
// Reactive state
watch('.todo-list', function*() {
  const todos = createState('todos', []);
  
  yield todos.init();
  
  // Update display when todos change
  const renderTodos = () => {
    const todoList = todos.get();
    html(todoList.map(todo => `<li>${todo.text}</li>`).join(''))(instance);
  };
  
  yield on('todo-added', (_, instance) => {
    renderTodos();
  });
  
  yield on('todo-removed', (_, instance) => {
    renderTodos();
  });
});
```

## Testing

```typescript
// Testable components
export function createCounter(selector: string) {
  return watch(selector, function*() {
    const count = createState('count', 0);
    
    yield count.init();
    yield text(`Count: ${count.get()}`);
    
    yield on('click', (_, instance) => {
      count.update(c => c + 1);
      text(`Count: ${count.get()}`)(instance);
    });
    
    // Return test API
    return {
      getCount: () => count.get(),
      increment: () => count.update(c => c + 1),
      reset: () => count.set(0)
    };
  });
}

// Test usage
const counter = createCounter('.test-counter');
counter.increment();
expect(counter.getCount()).toBe(1);
```

## Implementation Details

### Core Observer System

```typescript
// Shared observer for performance
const globalObserver = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    // Handle all watch instances efficiently
    processWatchMutation(mutation);
  });
});

// Efficient element matching
function findMatchingElements(root: Element, subject: WatchSubject): HTMLElement[] {
  if (typeof subject === 'string') {
    return Array.from(root.querySelectorAll(subject));
  } else if (typeof subject === 'function') {
    const matches: HTMLElement[] = [];
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_ELEMENT,
      {
        acceptNode: (node) => {
          if (node instanceof HTMLElement && subject(node)) {
            matches.push(node);
          }
          return NodeFilter.FILTER_SKIP;
        }
      }
    );
    while (walker.nextNode()) {
      // TreeWalker handles the matching
    }
    return matches;
  } else {
    return subject instanceof HTMLElement ? [subject] : [];
  }
}
```

### Memory Management

```typescript
// Automatic cleanup with WeakMaps
const instanceStates = new WeakMap<HTMLElement, Record<string, any>>();
const instanceObservers = new WeakMap<HTMLElement, Set<Observer>>();
const instanceCleanupFns = new WeakMap<HTMLElement, (() => void)[]>();

// Cleanup on element removal
function cleanupInstance(element: HTMLElement) {
  const observers = instanceObservers.get(element);
  if (observers) {
    observers.forEach(observer => observer.disconnect());
    observers.clear();
  }
  
  const cleanupFns = instanceCleanupFns.get(element);
  if (cleanupFns) {
    cleanupFns.forEach(fn => fn());
    cleanupFns.length = 0;
  }
  
  instanceStates.delete(element);
  instanceObservers.delete(element);
  instanceCleanupFns.delete(element);
}
```

## Migration Guide

### From v1/v2

```typescript
// v1/v2 style
watch('.button', ({ on, state, el }) => {
  state.count = 0;
  on('click', () => {
    state.count++;
    el.textContent = `Count: ${state.count}`;
  });
});

// v4 equivalent
watch('.button', function*() {
  const count = createState('count', 0);
  
  yield count.init();
  yield on('click', (_, instance) => {
    count.update(c => c + 1);
    text(`Count: ${count.get()}`)(instance);
  });
});
```

### From Direct DOM Manipulation

```typescript
// Before
const button = document.querySelector('.button');
button.textContent = 'Click me';
button.classList.add('primary');
button.addEventListener('click', () => {
  console.log('Clicked!');
});

// After
watch('.button', function*() {
  yield text('Click me');
  yield addClass('primary');
  yield on('click', () => {
    console.log('Clicked!');
  });
});

// Or directly
const button = document.querySelector('.button');
text(button, 'Click me');
addClass(button, 'primary');
on(button, 'click', () => {
  console.log('Clicked!');
});
```

## Best Practices

### 1. Start Simple

```typescript
// Begin with direct usage
text(element, 'Hello');
addClass(element, 'active');

// Upgrade to generators when needed
watch('.dynamic-content', function*() {
  yield text('Hello');
  yield addClass('active');
});
```

### 2. Compose Behaviors

```typescript
// Create reusable patterns
const withAnimation = function*(duration = 300) {
  yield onMount((instance) => {
    animate(fadeIn(duration))(instance);
  });
};

const withClickCounter = function*() {
  const count = createState('count', 0);
  yield count.init();
  yield on('click', (_, instance) => {
    count.update(c => c + 1);
    text(`Count: ${count.get()}`)(instance);
  });
};

// Combine behaviors
watch('.interactive-button', function*() {
  yield* withAnimation();
  yield* withClickCounter();
});
```

### 3. Performance Considerations

```typescript
// Use parent scoping for large DOMs
watch('.item', setupFn, document.querySelector('.container'));

// Throttle expensive operations
watch('.scroll-target', function*() {
  yield throttle(16, (instance) => {
    // Expensive scroll calculations
  });
});

// Batch DOM updates
watch('.data-table', function*() {
  yield on('data-update', (_, instance) => {
    requestAnimationFrame(() => {
      // Batch multiple DOM updates
      els('td', instance.element).forEach(cell => {
        text(cell, getData(cell.dataset.id));
      });
    });
  });
});
```

## Conclusion

Watch v4 achieves the perfect balance:

- **Simple**: Direct function calls for immediate needs
- **Composable**: Generator functions for complex behaviors
- **Type-safe**: Comprehensive TypeScript without overwhelming complexity
- **Performant**: Battle-tested observer patterns with modern optimizations
- **Elegant**: The dual API pattern eliminates choice paralysis

The key insight is that every primitive can be used both directly and compositionally. This creates a natural progression from simple DOM manipulation to sophisticated component behavior, all with the same familiar functions.

Watch v4 is not just a library—it's a philosophy for elegant DOM interaction that scales from single interactions to complex applications.
