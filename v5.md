# Watch v5: The Elegant Kernel

## Philosophy

Watch v5 combines the best ideas from all previous versions into an **elegant, type-safe kernel** for DOM observation. It provides **dual APIs** - direct usage for immediate needs and generator composition for complex behaviors - all built on a **minimal, performant core**.

### Core Principles

1. **Dual API Pattern**: Every function works both directly and in generators
2. **Type Safety First**: Beautiful type flow from selectors to event handlers  
3. **Minimal Kernel**: Core does only DOM observation + function application
4. **Pure Functions**: No side effects in core, predictable behavior
5. **Universal Composition**: Generators + function composition everywhere
6. **Zero Magic**: Explicit, transparent behavior
7. **Extension Points**: Easy to build any abstraction on top

## The Kernel

### Single Global Observer

```typescript
// One observer for the entire application
const globalObserver = new MutationObserver(processMutations);
globalObserver.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true
});

// Selector registry - Map<selector, Set<handler>>
const selectorHandlers = new Map<string, Set<ElementHandler>>();

// Process mutations efficiently
function processMutations(mutations: MutationRecord[]) {
  const elementsToProcess = new Set<HTMLElement>();
  
  mutations.forEach(mutation => {
    // Collect all elements that need processing
    if (mutation.type === 'childList') {
      mutation.addedNodes.forEach(node => {
        if (node instanceof HTMLElement) {
          collectElements(node, elementsToProcess);
        }
      });
    }
    
    if (mutation.type === 'attributes') {
      if (mutation.target instanceof HTMLElement) {
        elementsToProcess.add(mutation.target);
      }
    }
  });
  
  // Process all elements once
  processElements(elementsToProcess);
}

function collectElements(root: HTMLElement, collector: Set<HTMLElement>) {
  collector.add(root);
  root.querySelectorAll('*').forEach(child => {
    if (child instanceof HTMLElement) {
      collector.add(child);
    }
  });
}

function processElements(elements: Set<HTMLElement>) {
  selectorHandlers.forEach((handlers, selector) => {
    elements.forEach(element => {
      if (element.matches(selector)) {
        handlers.forEach(handler => handler(element));
      }
    });
  });
}
```

### Core Types

```typescript
// Type-safe core types with element inference
type ElementHandler<El extends HTMLElement = HTMLElement> = (element: El) => void;
type ElementFn<El extends HTMLElement = HTMLElement, T = void> = (element: El) => T;
type Selector = string;

// Element type inference from selectors
type ElementFromSelector<S extends string> = 
  S extends `input${string}` ? HTMLInputElement :
  S extends `button${string}` ? HTMLButtonElement :
  S extends `form${string}` ? HTMLFormElement :
  S extends `a${string}` ? HTMLAnchorElement :
  S extends `img${string}` ? HTMLImageElement :
  S extends `select${string}` ? HTMLSelectElement :
  S extends `textarea${string}` ? HTMLTextAreaElement :
  HTMLElement;

// Type-safe registration function
function register<S extends string>(
  selector: S, 
  handler: ElementHandler<ElementFromSelector<S>>
): () => void {
  type El = ElementFromSelector<S>;
  
  if (!selectorHandlers.has(selector)) {
    selectorHandlers.set(selector, new Set());
  }
  
  const handlers = selectorHandlers.get(selector)!;
  handlers.add(handler as ElementHandler);
  
  // Apply to existing elements with proper typing
  document.querySelectorAll(selector).forEach(element => {
    if (element instanceof HTMLElement) {
      handler(element as El);
    }
  });
  
  // Return unregister function
  return () => {
    handlers.delete(handler as ElementHandler);
    if (handlers.size === 0) {
      selectorHandlers.delete(selector);
    }
  };
}

// Overloaded watch function with intelligent type inference

// 1. String selector - infer element type from selector
function watch<S extends string>(
  selector: S, 
  generator: () => Generator<ElementFn<ElementFromSelector<S>>, void, unknown>
): () => void;

// 2. Single element - infer exact element type
function watch<El extends HTMLElement>(
  element: El,
  generator: () => Generator<ElementFn<El>, void, unknown>
): () => void;

// 3. Matcher function - HTMLElement
function watch(
  matcher: (element: HTMLElement) => boolean,
  generator: () => Generator<ElementFn<HTMLElement>, void, unknown>
): () => void;

// 4. Array of elements - infer union type
function watch<El extends HTMLElement>(
  elements: El[],
  generator: () => Generator<ElementFn<El>, void, unknown>
): () => void;

// 5. NodeList - infer element type
function watch<El extends HTMLElement>(
  nodeList: NodeListOf<El>,
  generator: () => Generator<ElementFn<El>, void, unknown>
): () => void;

// 6. Event Delegation - parent element with child selector
function watch<Parent extends HTMLElement, S extends string>(
  parent: Parent,
  childSelector: S,
  generator: () => Generator<ElementFn<ElementFromSelector<S>>, void, unknown>
): () => void;

// Implementation
function watch<T extends string | HTMLElement | HTMLElement[] | NodeListOf<HTMLElement> | ((el: HTMLElement) => boolean)>(
  target: T,
  selectorOrGenerator?: string | (() => Generator<ElementFn<any>, void, unknown>),
  generator?: () => Generator<ElementFn<any>, void, unknown>
): () => void {
  // Handle event delegation case: watch(parent, childSelector, generator)
  if (arguments.length === 3 && target instanceof HTMLElement && typeof selectorOrGenerator === 'string') {
    const parent = target;
    const childSelector = selectorOrGenerator;
    const delegatedGenerator = generator!;
    
    // Create delegation handler
    const delegationHandler = (event: Event) => {
      const target = event.target as HTMLElement;
      const matchedChild = target.closest(childSelector) as HTMLElement;
      
      if (matchedChild && parent.contains(matchedChild)) {
        // Run generator for the matched child
        const gen = delegatedGenerator();
        let result = gen.next();
        
        while (!result.done) {
          const elementFn = result.value;
          // Check if this is an event handler function
          if (elementFn.toString().includes('addEventListener')) {
            // For delegated events, we need to set up the handler differently
            // The event has already fired, so we handle it directly
            elementFn(matchedChild);
          } else {
            // For non-event functions, apply immediately
            elementFn(matchedChild);
          }
          result = gen.next();
        }
      }
    };
    
    // Add delegation listener to parent
    parent.addEventListener('click', delegationHandler, true);
    parent.addEventListener('input', delegationHandler, true);
    parent.addEventListener('change', delegationHandler, true);
    parent.addEventListener('submit', delegationHandler, true);
    parent.addEventListener('focus', delegationHandler, true);
    parent.addEventListener('blur', delegationHandler, true);
    
    // Also apply to existing matching children
    parent.querySelectorAll(childSelector).forEach(child => {
      if (child instanceof HTMLElement) {
        const gen = delegatedGenerator();
        let result = gen.next();
        
        while (!result.done) {
          const elementFn = result.value;
          elementFn(child);
          result = gen.next();
        }
      }
    });
    
    return () => {
      parent.removeEventListener('click', delegationHandler, true);
      parent.removeEventListener('input', delegationHandler, true);
      parent.removeEventListener('change', delegationHandler, true);
      parent.removeEventListener('submit', delegationHandler, true);
      parent.removeEventListener('focus', delegationHandler, true);
      parent.removeEventListener('blur', delegationHandler, true);
    };
  }
  
  // Handle normal cases: watch(target, generator)
  const actualGenerator = (selectorOrGenerator as () => Generator<ElementFn<any>, void, unknown>);
  // String selector - traditional observation
  if (typeof target === 'string') {
    const setupFn: ElementFn<any> = (element) => {
      const gen = actualGenerator();
      let result = gen.next();
      
      while (!result.done) {
        const elementFn = result.value;
        elementFn(element);
        result = gen.next();
      }
    };
    
    return register(target, setupFn);
  }
  
  // Single element - apply immediately + observe for removal
  if (target instanceof HTMLElement) {
    const setupFn: ElementFn<any> = (element) => {
      const gen = actualGenerator();
      let result = gen.next();
      
      while (!result.done) {
        const elementFn = result.value;
        elementFn(element);
        result = gen.next();
      }
    };
    
    // Apply immediately
    setupFn(target);
    
    // Observe for removal
    const removalObserver = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.removedNodes.forEach(node => {
          if (node === target || (node instanceof Element && node.contains(target))) {
            // Element was removed - cleanup if needed
            removalObserver.disconnect();
          }
        });
      });
    });
    
    if (target.parentNode) {
      removalObserver.observe(target.parentNode, { childList: true, subtree: true });
    }
    
    return () => removalObserver.disconnect();
  }
  
  // Matcher function - observe all elements
  if (typeof target === 'function') {
    const matcher = target;
    const setupFn: ElementFn<HTMLElement> = (element) => {
      if (matcher(element)) {
        const gen = actualGenerator();
        let result = gen.next();
        
        while (!result.done) {
          const elementFn = result.value;
          elementFn(element);
          result = gen.next();
        }
      }
    };
    
    // Apply to existing elements
    document.querySelectorAll('*').forEach(el => {
      if (el instanceof HTMLElement) {
        setupFn(el);
      }
    });
    
    // Observe for new elements
    const matcherObserver = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node instanceof HTMLElement) {
            setupFn(node);
            // Also check children
            node.querySelectorAll('*').forEach(child => {
              if (child instanceof HTMLElement) {
                setupFn(child);
              }
            });
          }
        });
      });
    });
    
    matcherObserver.observe(document.body, { childList: true, subtree: true });
    return () => matcherObserver.disconnect();
  }
  
  // Array of elements or NodeList - apply to each
  const elements = Array.isArray(target) ? target : Array.from(target);
  const cleanupFns: (() => void)[] = [];
  
  elements.forEach(element => {
    if (element instanceof HTMLElement) {
      const setupFn: ElementFn<any> = (el) => {
        const gen = actualGenerator();
        let result = gen.next();
        
        while (!result.done) {
          const elementFn = result.value;
          elementFn(el);
          result = gen.next();
        }
      };
      
      setupFn(element);
      
      // Observe for removal
      const removalObserver = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          mutation.removedNodes.forEach(node => {
            if (node === element || (node instanceof Element && node.contains(element))) {
              removalObserver.disconnect();
            }
          });
        });
      });
      
      if (element.parentNode) {
        removalObserver.observe(element.parentNode, { childList: true, subtree: true });
        cleanupFns.push(() => removalObserver.disconnect());
      }
    }
  });
  
  return () => {
    cleanupFns.forEach(fn => fn());
  };
}
```

## Generator System

### Core Generator Support

```typescript
// Generator-based watch function
function watch<S extends string>(
  selector: S,
  generator: () => Generator<ElementFn<ElementFromSelector<S>>, void, unknown>
): () => void {
  const setupFn: ElementFn<ElementFromSelector<S>> = (element) => {
    const gen = generator();
    let result = gen.next();
    
    while (!result.done) {
      const elementFn = result.value;
      elementFn(element);
      result = gen.next();
    }
  };
  
  return register(selector, setupFn);
}

// Helper for running generators on specific elements
function* runGenerator<El extends HTMLElement>(
  element: El,
  generator: () => Generator<ElementFn<El>, void, unknown>
) {
  const gen = generator();
  let result = gen.next();
  
  while (!result.done) {
    const elementFn = result.value;
    elementFn(element);
    result = gen.next();
  }
}
```

### Overloaded Function APIs

```typescript
// The Dual API Pattern - every function works both ways

// TEXT - Direct usage and generator usage
function text<El extends HTMLElement>(element: El, content: string): void;
function text<El extends HTMLElement = HTMLElement>(content: string): ElementFn<El>;
function text<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, content] = args;
    element.textContent = content;
  } else {
    const [content] = args;
    return (element: El) => {
      element.textContent = content;
    };
  }
}

// CLASSES - Add, remove, toggle with dual API
function addClass<El extends HTMLElement>(element: El, className: string): void;
function addClass<El extends HTMLElement = HTMLElement>(className: string): ElementFn<El>;
function addClass<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, className] = args;
    element.classList.add(className);
  } else {
    const [className] = args;
    return (element: El) => {
      element.classList.add(className);
    };
  }
}

function removeClass<El extends HTMLElement>(element: El, className: string): void;
function removeClass<El extends HTMLElement = HTMLElement>(className: string): ElementFn<El>;
function removeClass<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, className] = args;
    element.classList.remove(className);
  } else {
    const [className] = args;
    return (element: El) => {
      element.classList.remove(className);
    };
  }
}

function toggleClass<El extends HTMLElement>(element: El, className: string, force?: boolean): void;
function toggleClass<El extends HTMLElement = HTMLElement>(className: string, force?: boolean): ElementFn<El>;
function toggleClass<El extends HTMLElement>(...args: any[]): any {
  if (args.length >= 2 && typeof args[0] === 'object') {
    const [element, className, force] = args;
    element.classList.toggle(className, force);
  } else {
    const [className, force] = args;
    return (element: El) => {
      element.classList.toggle(className, force);
    };
  }
}

// STYLES - Direct and generator usage
function style<El extends HTMLElement>(element: El, property: string, value: string): void;
function style<El extends HTMLElement = HTMLElement>(property: string, value: string): ElementFn<El>;
function style<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 3) {
    const [element, property, value] = args;
    (element.style as any)[property] = value;
  } else {
    const [property, value] = args;
    return (element: El) => {
      (element.style as any)[property] = value;
    };
  }
}

// ATTRIBUTES - Direct and generator usage
function attr<El extends HTMLElement>(element: El, name: string, value: string): void;
function attr<El extends HTMLElement = HTMLElement>(name: string, value: string): ElementFn<El>;
function attr<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 3) {
    const [element, name, value] = args;
    element.setAttribute(name, value);
  } else {
    const [name, value] = args;
    return (element: El) => {
      element.setAttribute(name, value);
    };
  }
}

// EVENTS - Type-safe event handling without 'this'
function on<El extends HTMLElement, K extends keyof HTMLElementEventMap>(
  element: El, 
  event: K, 
  handler: (event: HTMLElementEventMap[K], element: El) => void
): () => void;
function on<El extends HTMLElement, K extends keyof HTMLElementEventMap>(
  event: K,
  handler: (event: HTMLElementEventMap[K], element: El) => void
): ElementFn<El, () => void>;
function on<El extends HTMLElement, K extends keyof HTMLElementEventMap>(...args: any[]): any {
  if (args.length === 3) {
    const [element, event, handler] = args;
    const wrappedHandler = (e: Event) => handler(e as HTMLElementEventMap[K], element);
    element.addEventListener(event, wrappedHandler);
    return () => element.removeEventListener(event, wrappedHandler);
  } else {
    const [event, handler] = args;
    return (element: El) => {
      const wrappedHandler = (e: Event) => handler(e as HTMLElementEventMap[K], element);
      element.addEventListener(event, wrappedHandler);
      return () => element.removeEventListener(event, wrappedHandler);
    };
  }
}

// SOPHISTICATED OBSERVER EVENTS - The ergonomic API from original Watch

// Attribute changes with old/new values
function onAttr<El extends HTMLElement>(
  element: El,
  filter: string | RegExp,
  handler: (mutation: {
    attributeName: string;
    oldValue: string | null;
    newValue: string | null;
    element: El;
  }) => void
): () => void;
function onAttr<El extends HTMLElement>(
  filter: string | RegExp,
  handler: (mutation: {
    attributeName: string;
    oldValue: string | null;
    newValue: string | null;
    element: El;
  }) => void
): ElementFn<El>;
function onAttr<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 3) {
    const [element, filter, handler] = args;
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.target === element) {
          const attributeName = mutation.attributeName!;
          let shouldHandle = false;
          
          if (typeof filter === 'string') {
            shouldHandle = attributeName === filter;
          } else {
            shouldHandle = filter.test(attributeName);
          }
          
          if (shouldHandle) {
            handler({
              attributeName,
              oldValue: mutation.oldValue,
              newValue: element.getAttribute(attributeName),
              element: element as El
            });
          }
        }
      });
    });
    
    observer.observe(element, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: typeof filter === 'string' ? [filter] : undefined
    });
    
    return () => observer.disconnect();
  } else {
    const [filter, handler] = args;
    return (element: El) => {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.target === element) {
            const attributeName = mutation.attributeName!;
            let shouldHandle = false;
            
            if (typeof filter === 'string') {
              shouldHandle = attributeName === filter;
            } else {
              shouldHandle = filter.test(attributeName);
            }
            
            if (shouldHandle) {
              handler({
                attributeName,
                oldValue: mutation.oldValue,
                newValue: element.getAttribute(attributeName),
                element
              });
            }
          }
        });
      });
      
      observer.observe(element, {
        attributes: true,
        attributeOldValue: true,
        attributeFilter: typeof filter === 'string' ? [filter] : undefined
      });
      
      return () => observer.disconnect();
    };
  }
}

// Text content changes with old/new values
function onText<El extends HTMLElement>(
  element: El,
  handler: (change: {
    oldText: string;
    newText: string;
    element: El;
  }) => void
): () => void;
function onText<El extends HTMLElement>(
  handler: (change: {
    oldText: string;
    newText: string;
    element: El;
  }) => void
): ElementFn<El>;
function onText<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, handler] = args;
    let oldText = element.textContent || '';
    
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' || mutation.type === 'characterData') {
          const newText = element.textContent || '';
          if (newText !== oldText) {
            handler({
              oldText,
              newText,
              element: element as El
            });
            oldText = newText;
          }
        }
      });
    });
    
    observer.observe(element, {
      childList: true,
      subtree: true,
      characterData: true,
      characterDataOldValue: true
    });
    
    return () => observer.disconnect();
  } else {
    const [handler] = args;
    return (element: El) => {
      let oldText = element.textContent || '';
      
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            const newText = element.textContent || '';
            if (newText !== oldText) {
              handler({
                oldText,
                newText,
                element
              });
              oldText = newText;
            }
          }
        });
      });
      
      observer.observe(element, {
        childList: true,
        subtree: true,
        characterData: true,
        characterDataOldValue: true
      });
      
      return () => observer.disconnect();
    };
  }
}

// Visibility changes with intersection details
function onVisible<El extends HTMLElement>(
  element: El,
  handler: (visibility: {
    isVisible: boolean;
    intersectionRatio: number;
    boundingClientRect: DOMRectReadOnly;
    element: El;
  }) => void,
  options?: IntersectionObserverInit
): () => void;
function onVisible<El extends HTMLElement>(
  handler: (visibility: {
    isVisible: boolean;
    intersectionRatio: number;
    boundingClientRect: DOMRectReadOnly;
    element: El;
  }) => void,
  options?: IntersectionObserverInit
): ElementFn<El>;
function onVisible<El extends HTMLElement>(...args: any[]): any {
  if (args.length >= 2 && typeof args[0] === 'object' && 'nodeType' in args[0]) {
    const [element, handler, options] = args;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.target === element) {
          handler({
            isVisible: entry.isIntersecting,
            intersectionRatio: entry.intersectionRatio,
            boundingClientRect: entry.boundingClientRect,
            element: element as El
          });
        }
      });
    }, options);
    
    observer.observe(element);
    return () => observer.disconnect();
  } else {
    const [handler, options] = args;
    return (element: El) => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.target === element) {
            handler({
              isVisible: entry.isIntersecting,
              intersectionRatio: entry.intersectionRatio,
              boundingClientRect: entry.boundingClientRect,
              element
            });
          }
        });
      }, options);
      
      observer.observe(element);
      return () => observer.disconnect();
    };
  }
}

// Resize changes with detailed measurements
function onResize<El extends HTMLElement>(
  element: El,
  handler: (resize: {
    contentRect: DOMRectReadOnly;
    borderBoxSize: ResizeObserverSize[];
    contentBoxSize: ResizeObserverSize[];
    element: El;
  }) => void
): () => void;
function onResize<El extends HTMLElement>(
  handler: (resize: {
    contentRect: DOMRectReadOnly;
    borderBoxSize: ResizeObserverSize[];
    contentBoxSize: ResizeObserverSize[];
    element: El;
  }) => void
): ElementFn<El>;
function onResize<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, handler] = args;
    const observer = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.target === element) {
          handler({
            contentRect: entry.contentRect,
            borderBoxSize: entry.borderBoxSize,
            contentBoxSize: entry.contentBoxSize,
            element: element as El
          });
        }
      });
    });
    
    observer.observe(element);
    return () => observer.disconnect();
  } else {
    const [handler] = args;
    return (element: El) => {
      const observer = new ResizeObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.target === element) {
            handler({
              contentRect: entry.contentRect,
              borderBoxSize: entry.borderBoxSize,
              contentBoxSize: entry.contentBoxSize,
              element
            });
          }
        });
      });
      
      observer.observe(element);
      return () => observer.disconnect();
    };
  }
}

// Lifecycle events - mount and unmount
function onMount<El extends HTMLElement>(
  element: El,
  handler: (element: El) => void
): () => void;
function onMount<El extends HTMLElement>(
  handler: (element: El) => void
): ElementFn<El>;
function onMount<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, handler] = args;
    // Call immediately for existing elements
    handler(element as El);
    return () => {}; // No cleanup needed for mount
  } else {
    const [handler] = args;
    return (element: El) => {
      handler(element);
      return () => {}; // No cleanup needed for mount
    };
  }
}

function onUnmount<El extends HTMLElement>(
  element: El,
  handler: (element: El) => void
): () => void;
function onUnmount<El extends HTMLElement>(
  handler: (element: El) => void
): ElementFn<El>;
function onUnmount<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, handler] = args;
    // Store unmount handler for later execution
    if (!unmountHandlers.has(element)) {
      unmountHandlers.set(element, new Set());
    }
    unmountHandlers.get(element)!.add(handler);
    
    return () => {
      unmountHandlers.get(element)?.delete(handler);
    };
  } else {
    const [handler] = args;
    return (element: El) => {
      if (!unmountHandlers.has(element)) {
        unmountHandlers.set(element, new Set());
      }
      unmountHandlers.get(element)!.add(handler);
      
      return () => {
        unmountHandlers.get(element)?.delete(handler);
      };
    };
  }
}

// Global unmount handler storage
const unmountHandlers = new WeakMap<HTMLElement, Set<(element: HTMLElement) => void>>();

// Helper to trigger unmount handlers when elements are removed
function triggerUnmountHandlers(element: HTMLElement) {
  const handlers = unmountHandlers.get(element);
  if (handlers) {
    handlers.forEach(handler => handler(element));
    unmountHandlers.delete(element);
  }
}

// FORM VALUES - Type-safe form handling
function value<El extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>(
  element: El, 
  val: string
): void;
function value<El extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>(
  val: string
): ElementFn<El>;
function value<El extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, val] = args;
    element.value = val;
  } else {
    const [val] = args;
    return (element: El) => {
      element.value = val;
    };
  }
}

function checked<El extends HTMLInputElement>(element: El, isChecked: boolean): void;
function checked<El extends HTMLInputElement>(isChecked: boolean): ElementFn<El>;
function checked<El extends HTMLInputElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, isChecked] = args;
    element.checked = isChecked;
  } else {
    const [isChecked] = args;
    return (element: El) => {
      element.checked = isChecked;
    };
  }
}

// PROPERTIES - Type-safe property access
function prop<El extends HTMLElement, K extends keyof El>(
  element: El, 
  property: K, 
  value: El[K]
): void;
function prop<El extends HTMLElement, K extends keyof El>(
  property: K, 
  value: El[K]
): ElementFn<El>;
function prop<El extends HTMLElement, K extends keyof El>(...args: any[]): any {
  if (args.length === 3) {
    const [element, property, value] = args;
    element[property] = value;
  } else {
    const [property, value] = args;
    return (element: El) => {
      element[property] = value;
    };
  }
}

// HTML CONTENT - Inner HTML manipulation
function html<El extends HTMLElement>(element: El, content: string): void;
function html<El extends HTMLElement>(element: El): string;
function html<El extends HTMLElement>(content: string): ElementFn<El>;
function html<El extends HTMLElement>(): ElementFn<El, string>;
function html<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, content] = args;
    element.innerHTML = content;
  } else if (args.length === 1 && typeof args[0] === 'object') {
    const [element] = args;
    return element.innerHTML;
  } else if (args.length === 1) {
    const [content] = args;
    return (element: El) => {
      element.innerHTML = content;
    };
  } else {
    return (element: El) => element.innerHTML;
  }
}

// DATA ATTRIBUTES - Dataset manipulation
function data<El extends HTMLElement>(element: El, key: string, value: string): void;
function data<El extends HTMLElement>(element: El, key: string): string | undefined;
function data<El extends HTMLElement>(key: string, value: string): ElementFn<El>;
function data<El extends HTMLElement>(key: string): ElementFn<El, string | undefined>;
function data<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 3) {
    const [element, key, value] = args;
    element.dataset[key] = value;
  } else if (args.length === 2 && typeof args[0] === 'object') {
    const [element, key] = args;
    return element.dataset[key];
  } else if (args.length === 2) {
    const [key, value] = args;
    return (element: El) => {
      element.dataset[key] = value;
    };
  } else {
    const [key] = args;
    return (element: El) => element.dataset[key];
  }
}

// DOM TRAVERSAL - Query and navigation helpers
function el<T extends HTMLElement = HTMLElement>(element: HTMLElement, selector: string): T | null;
function el<T extends HTMLElement = HTMLElement>(selector: string): ElementFn<HTMLElement, T | null>;
function el<T extends HTMLElement = HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, selector] = args;
    return element.querySelector<T>(selector);
  } else {
    const [selector] = args;
    return (element: HTMLElement) => element.querySelector<T>(selector);
  }
}

function els<T extends HTMLElement = HTMLElement>(element: HTMLElement, selector: string): T[];
function els<T extends HTMLElement = HTMLElement>(selector: string): ElementFn<HTMLElement, T[]>;
function els<T extends HTMLElement = HTMLElement>(...args: any[]): any {
  if (args.length === 2) {
    const [element, selector] = args;
    return Array.from(element.querySelectorAll<T>(selector));
  } else {
    const [selector] = args;
    return (element: HTMLElement) => Array.from(element.querySelectorAll<T>(selector));
  }
}

function parent<T extends HTMLElement = HTMLElement>(element: HTMLElement, selector?: string): T | null;
function parent<T extends HTMLElement = HTMLElement>(selector?: string): ElementFn<HTMLElement, T | null>;
function parent<T extends HTMLElement = HTMLElement>(...args: any[]): any {
  if (args.length >= 1 && typeof args[0] === 'object') {
    const [element, selector] = args;
    if (selector) {
      return element.closest<T>(selector);
    }
    return element.parentElement as T | null;
  } else {
    const [selector] = args;
    return (element: HTMLElement) => {
      if (selector) {
        return element.closest<T>(selector);
      }
      return element.parentElement as T | null;
    };
  }
}

function siblings<T extends HTMLElement = HTMLElement>(element: HTMLElement, selector?: string): T[];
function siblings<T extends HTMLElement = HTMLElement>(selector?: string): ElementFn<HTMLElement, T[]>;
function siblings<T extends HTMLElement = HTMLElement>(...args: any[]): any {
  if (args.length >= 1 && typeof args[0] === 'object') {
    const [element, selector] = args;
    const parent = element.parentElement;
    if (!parent) return [];
    
    const allSiblings = Array.from(parent.children) as T[];
    const filtered = allSiblings.filter(sibling => sibling !== element);
    
    return selector ? filtered.filter(sibling => sibling.matches(selector)) : filtered;
  } else {
    const [selector] = args;
    return (element: HTMLElement) => {
      const parent = element.parentElement;
      if (!parent) return [];
      
      const allSiblings = Array.from(parent.children) as T[];
      const filtered = allSiblings.filter(sibling => sibling !== element);
      
      return selector ? filtered.filter(sibling => sibling.matches(selector)) : filtered;
    };
  }
}

// DOM INSERTION AND REMOVAL
function append<El extends HTMLElement>(element: El, ...content: (HTMLElement | string)[]): void;
function append<El extends HTMLElement>(...content: (HTMLElement | string)[]): ElementFn<El>;
function append<El extends HTMLElement>(...args: any[]): any {
  if (args.length > 0 && typeof args[0] === 'object' && 'nodeType' in args[0]) {
    const [element, ...content] = args;
    content.forEach(item => {
      if (typeof item === 'string') {
        element.insertAdjacentHTML('beforeend', item);
      } else {
        element.appendChild(item);
      }
    });
  } else {
    const content = args;
    return (element: El) => {
      content.forEach(item => {
        if (typeof item === 'string') {
          element.insertAdjacentHTML('beforeend', item);
        } else {
          element.appendChild(item);
        }
      });
    };
  }
}

function prepend<El extends HTMLElement>(element: El, ...content: (HTMLElement | string)[]): void;
function prepend<El extends HTMLElement>(...content: (HTMLElement | string)[]): ElementFn<El>;
function prepend<El extends HTMLElement>(...args: any[]): any {
  if (args.length > 0 && typeof args[0] === 'object' && 'nodeType' in args[0]) {
    const [element, ...content] = args;
    content.forEach(item => {
      if (typeof item === 'string') {
        element.insertAdjacentHTML('afterbegin', item);
      } else {
        element.insertBefore(item, element.firstChild);
      }
    });
  } else {
    const content = args;
    return (element: El) => {
      content.forEach(item => {
        if (typeof item === 'string') {
          element.insertAdjacentHTML('afterbegin', item);
        } else {
          element.insertBefore(item, element.firstChild);
        }
      });
    };
  }
}

function remove<El extends HTMLElement>(element: El): void;
function remove<El extends HTMLElement>(): ElementFn<El>;
function remove<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 1) {
    const [element] = args;
    element.remove();
    // Trigger unmount handlers
    triggerUnmountHandlers(element);
  } else {
    return (element: El) => {
      element.remove();
      triggerUnmountHandlers(element);
    };
  }
}

// UTILITY FUNCTIONS
function debounce<El extends HTMLElement>(ms: number, fn: ElementFn<El>): ElementFn<El>;
function debounce<El extends HTMLElement>(ms: number, fn: ElementFn<El>): ElementFn<El> {
  const timeouts = new WeakMap<El, number>();
  
  return (element: El) => {
    const existingTimeout = timeouts.get(element);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
    }
    
    const timeout = setTimeout(() => {
      fn(element);
      timeouts.delete(element);
    }, ms);
    
    timeouts.set(element, timeout);
  };
}

function throttle<El extends HTMLElement>(ms: number, fn: ElementFn<El>): ElementFn<El> {
  const lastRun = new WeakMap<El, number>();
  
  return (element: El) => {
    const now = Date.now();
    const last = lastRun.get(element) || 0;
    
    if (now - last >= ms) {
      fn(element);
      lastRun.set(element, now);
    }
  };
}

function once<El extends HTMLElement>(fn: ElementFn<El>): ElementFn<El> {
  const executed = new WeakSet<El>();
  
  return (element: El) => {
    if (!executed.has(element)) {
      fn(element);
      executed.add(element);
    }
  };
}

function delay<El extends HTMLElement>(ms: number, fn: ElementFn<El>): ElementFn<El> {
  return (element: El) => {
    setTimeout(() => fn(element), ms);
  };
}

function safely<El extends HTMLElement, T>(fn: ElementFn<El, T>, fallback?: T): ElementFn<El, T | undefined> {
  return (element: El) => {
    try {
      return fn(element);
    } catch (error) {
      console.warn('Watch function error:', error);
      return fallback;
    }
  };
}

function when<El extends HTMLElement>(
  condition: ElementFn<El, boolean>,
  then: ElementFn<El>,
  otherwise?: ElementFn<El>
): ElementFn<El> {
  return (element: El) => {
    if (condition(element)) {
      then(element);
    } else if (otherwise) {
      otherwise(element);
    }
  };
}

// MEASUREMENT UTILITIES
function rect<El extends HTMLElement>(element: El): DOMRect;
function rect<El extends HTMLElement>(): ElementFn<El, DOMRect>;
function rect<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 1) {
    const [element] = args;
    return element.getBoundingClientRect();
  } else {
    return (element: El) => element.getBoundingClientRect();
  }
}

function offset<El extends HTMLElement>(element: El): { top: number; left: number };
function offset<El extends HTMLElement>(): ElementFn<El, { top: number; left: number }>;
function offset<El extends HTMLElement>(...args: any[]): any {
  if (args.length === 1) {
    const [element] = args;
    return { top: element.offsetTop, left: element.offsetLeft };
  } else {
    return (element: El) => ({ top: element.offsetTop, left: element.offsetLeft });
  }
}

// FORM UTILITIES
function serialize<El extends HTMLFormElement>(element: El): Record<string, string>;
function serialize<El extends HTMLFormElement>(): ElementFn<El, Record<string, string>>;
function serialize<El extends HTMLFormElement>(...args: any[]): any {
  if (args.length === 1) {
    const [element] = args;
    const formData = new FormData(element);
    const result: Record<string, string> = {};
    formData.forEach((value, key) => {
      result[key] = value.toString();
    });
    return result;
  } else {
    return (element: El) => {
      const formData = new FormData(element);
      const result: Record<string, string> = {};
      formData.forEach((value, key) => {
        result[key] = value.toString();
      });
      return result;
    };
  }
}

// BATCHING SYSTEM FOR PERFORMANCE
const batchScheduler = {
  pending: new Set<() => void>(),
  scheduled: false,
  
  add(fn: () => void) {
    this.pending.add(fn);
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => {
        this.pending.forEach(fn => fn());
        this.pending.clear();
        this.scheduled = false;
      });
    }
  }
};

function batch<El extends HTMLElement>(fn: ElementFn<El>): ElementFn<El> {
  return (element: El) => {
    batchScheduler.add(() => fn(element));
  };
}
```

## Usage Patterns

### Direct Usage (Immediate Effects)

```typescript
// Direct DOM manipulation - no generators needed
const emailInput = document.querySelector('input[type="email"]') as HTMLInputElement;
const submitButton = document.querySelector('button.submit') as HTMLButtonElement;

// Type-safe direct calls
text(emailInput, '');
attr(emailInput, 'placeholder', 'Enter email');
addClass(submitButton, 'primary');
style(submitButton, 'cursor', 'pointer');

// Direct event handling with proper typing
on(emailInput, 'input', (event, element) => {
  // element is HTMLInputElement, event is InputEvent
  const isValid = element.value.includes('@');
  toggleClass(element, 'invalid', !isValid);
});

on(submitButton, 'click', (event, element) => {
  // element is HTMLButtonElement, event is MouseEvent
  element.disabled = true;
  text(element, 'Loading...');
  event.preventDefault();
});
```

### Generator Usage with Intelligent Type Inference

```typescript
// 1. STRING SELECTOR - Element type inferred from selector
watch('input[type="email"]', function*() {
  yield value('');                    // TypeScript knows this is HTMLInputElement
  yield attr('placeholder', 'Email');
  yield on('input', (event, element) => {
    const isValid = element.value.includes('@');  // element is HTMLInputElement
    toggleClass(element, 'invalid', !isValid);
  });
});

// 2. SINGLE ELEMENT - Exact element type inferred
const myButton = document.querySelector('.special-button') as HTMLButtonElement;
watch(myButton, function*() {
  yield text('Special Button');
  yield on('click', (event, element) => {
    element.disabled = true;       // element is HTMLButtonElement (exact type)
    text(element, 'Loading...');
  });
});

// 3. MATCHER FUNCTION - Custom element matching
watch((element) => element.classList.contains('dynamic-item'), function*() {
  yield addClass('matched');
  yield on('click', (event, element) => {
    // element is HTMLElement (since we can't infer more specific type)
    console.log('Dynamic item clicked:', element);
  });
});

// 4. ARRAY OF ELEMENTS - Union type inferred
const buttons = Array.from(document.querySelectorAll('button'));
watch(buttons, function*() {
  yield addClass('bulk-processed');
  yield on('click', (event, element) => {
    element.disabled = true;       // element type inferred from array
  });
});

// 5. NODELIST - Element type inferred from NodeList
const inputs = document.querySelectorAll('input[type="text"]');
watch(inputs, function*() {
  yield on('focus', (event, element) => {
    addClass(element, 'focused');  // element is HTMLInputElement
    element.select();              // Type-safe method access
  });
});

// 6. EVENT DELEGATION - Parent with child selector (high performance!)
watch(document.body, '.dynamic-button', function*() {
  yield addClass('delegated');
  yield on('click', (event, element) => {
    // element is HTMLElement inferred from selector
    // Event delegation handles dynamically added buttons automatically
    text(element, 'Clicked via delegation!');
    addClass(element, 'clicked');
  });
});

// 7. MIXED TYPES - Complex scenarios
const formElements = [
  document.querySelector('input[type="email"]') as HTMLInputElement,
  document.querySelector('button[type="submit"]') as HTMLButtonElement
];

watch(formElements, function*() {
  yield on('focus', (event, element) => {
    // element is HTMLInputElement | HTMLButtonElement
    addClass(element, 'focused');
  });
});
```

### Sophisticated Observer Events

```typescript
// ATTRIBUTE WATCHING - Track specific attribute changes with old/new values
watch('input[data-validation]', function*() {
  // Watch specific attribute
  yield onAttr('data-validation', ({attributeName, oldValue, newValue, element}) => {
    console.log(`${attributeName} changed from ${oldValue} to ${newValue}`);
    if (newValue === 'error') {
      addClass(element, 'validation-error');
    }
  });
  
  // Watch multiple attributes with regex
  yield onAttr(/^data-/, ({attributeName, oldValue, newValue, element}) => {
    console.log(`Data attribute ${attributeName} updated`);
  });
});

// TEXT CONTENT WATCHING - Track text changes with old/new values  
watch('.live-counter', function*() {
  yield onText(({oldText, newText, element}) => {
    console.log(`Counter changed from "${oldText}" to "${newText}"`);
    
    // Animate text changes
    animate(element, [
      { transform: 'scale(1.2)', color: 'blue' },
      { transform: 'scale(1)', color: 'inherit' }
    ], { duration: 300 });
  });
});

// VISIBILITY WATCHING - Intersection observer with detailed info
watch('.lazy-image', function*() {
  yield onVisible(({isVisible, intersectionRatio, boundingClientRect, element}) => {
    if (isVisible && intersectionRatio > 0.5) {
      // Load image when 50% visible
      const src = element.dataset.src;
      if (src) {
        attr(element, 'src', src);
        addClass(element, 'loaded');
      }
    }
    
    // Update progress indicator
    const progressBar = element.querySelector('.load-progress');
    if (progressBar) {
      style(progressBar, 'width', `${intersectionRatio * 100}%`);
    }
  }, {
    threshold: [0, 0.25, 0.5, 0.75, 1.0] // Multiple thresholds
  });
});

// RESIZE WATCHING - ResizeObserver with detailed measurements
watch('.responsive-chart', function*() {
  yield onResize(({contentRect, borderBoxSize, contentBoxSize, element}) => {
    console.log('Element resized:', {
      width: contentRect.width,
      height: contentRect.height,
      borderBox: borderBoxSize[0],
      contentBox: contentBoxSize[0]
    });
    
    // Update chart dimensions
    updateChartSize(element, contentRect.width, contentRect.height);
    
    // Responsive breakpoints
    if (contentRect.width < 768) {
      addClass(element, 'mobile-layout');
    } else {
      removeClass(element, 'mobile-layout');
    }
  });
});

// LIFECYCLE EVENTS - Mount and unmount with proper cleanup
watch('.modal', function*() {
  yield onMount((element) => {
    console.log('Modal mounted:', element);
    addClass(element, 'mounted');
    
    // Set up modal-specific event listeners
    const backdrop = element.querySelector('.modal-backdrop');
    if (backdrop) {
      on(backdrop, 'click', () => {
        removeClass(element, 'open');
      });
    }
  });
  
  yield onUnmount((element) => {
    console.log('Modal unmounted:', element);
    
    // Cleanup modal-specific resources
    clearModalState(element);
    removeModalFromStack(element);
  });
  
  // Regular click handling
  yield on('click', (event, element) => {
    if (event.target.matches('.modal-close')) {
      removeClass(element, 'open');
    }
  });
});

// COMPLEX COMBINATIONS - Multiple observers working together
watch('.smart-form-field', function*() {
  // Track mount for initialization
  yield onMount((element) => {
    addClass(element, 'initialized');
    validateField(element);
  });
  
  // Track text changes for real-time validation
  yield onText(({newText, element}) => {
    validateField(element);
    saveFieldState(element, newText);
  });
  
  // Track attribute changes for dynamic validation rules
  yield onAttr('data-validation-rules', ({newValue, element}) => {
    updateValidationRules(element, JSON.parse(newValue || '{}'));
    validateField(element);
  });
  
  // Track visibility for performance optimization
  yield onVisible(({isVisible, element}) => {
    if (!isVisible) {
      pauseValidation(element);
    } else {
      resumeValidation(element);
    }
  });
  
  // Track resize for responsive validation messages
  yield onResize(({contentRect, element}) => {
    if (contentRect.width < 300) {
      addClass(element, 'compact-validation');
    } else {
      removeClass(element, 'compact-validation');
    }
  });
  
  // Handle cleanup
  yield onUnmount((element) => {
    clearValidationState(element);
    removeFromValidationQueue(element);
  });
});

// FORM VALIDATION WITH SOPHISTICATED OBSERVERS
watch('form.advanced-form', function*() {
  yield onMount((form) => {
    console.log('Advanced form initialized');
    initializeFormValidation(form);
  });
  
  // Watch for dynamic field additions/removals
  yield onText(({oldText, newText, element}) => {
    // Re-scan for new form fields if form HTML changed
    if (oldText !== newText) {
      rescanFormFields(element);
    }
  });
  
  // Watch for validation rule changes
  yield onAttr(/^data-validation/, ({attributeName, newValue, element}) => {
    updateFormValidationRules(element, attributeName, newValue);
  });
  
  yield onUnmount((form) => {
    clearFormValidation(form);
  });
});
```

### Event Delegation Patterns

```typescript
// HIGH PERFORMANCE: Event delegation for dynamic content
// Single listener handles all current and future buttons
watch(document.body, 'button.action', function*() {
  yield addClass('action-button');
  yield on('click', (event, button) => {
    // button is inferred as HTMLButtonElement from selector
    const action = button.dataset.action;
    
    if (action === 'delete') {
      button.closest('.item')?.remove();
    } else if (action === 'edit') {
      button.textContent = 'Editing...';
    }
  });
});

// Form delegation - handle all form inputs efficiently
watch(document.querySelector('.dynamic-form'), 'input, select, textarea', function*() {
  yield on('input', (event, element) => {
    // element type is inferred from the selector union
    validate(element);
    saveToLocalStorage(element.name, element.value);
  });
  
  yield on('focus', (event, element) => {
    addClass(element, 'focused');
  });
  
  yield on('blur', (event, element) => {
    removeClass(element, 'focused');
  });
});

// Modal delegation - single listener for all modals
watch(document.body, '[data-modal-trigger]', function*() {
  yield on('click', (event, trigger) => {
    const modalId = trigger.dataset.modalTrigger;
    const modal = document.querySelector(`#${modalId}`);
    if (modal) {
      addClass(modal, 'open');
    }
  });
});

// Complex delegation with type inference
const sidebar = document.querySelector('.sidebar') as HTMLElement;
watch(sidebar, '.nav-item[data-section]', function*() {
  yield on('click', (event, navItem) => {
    // Remove active from siblings
    navItem.parentElement?.querySelectorAll('.nav-item').forEach(item => {
      removeClass(item, 'active');
    });
    
    // Add active to clicked item
    addClass(navItem, 'active');
    
    // Show corresponding section
    const section = navItem.dataset.section;
    showSection(section);
  });
});

// Performance comparison:
// ❌ Bad: Individual listeners (100 buttons = 100 listeners)
// document.querySelectorAll('.item button').forEach(btn => {
//   btn.addEventListener('click', handler);
// });

// ✅ Good: Event delegation (100 buttons = 1 listener)
// watch(document.body, '.item button', function*() {
//   yield on('click', handler);
// });
```

### Advanced Generator Composition

```typescript
// Create reusable generator behaviors
function* primaryButton() {
  yield addClass('btn');
  yield addClass('btn-primary');
  yield style('cursor', 'pointer');
}

function* submitBehavior() {
  yield on('click', (event, element: HTMLButtonElement) => {
    element.disabled = true;           // TypeScript knows element is HTMLButtonElement
    text(element, 'Loading...');       // Type-safe direct call
    console.log('Button clicked:', event.type); // event is MouseEvent
  });
}

// Compose generators naturally
watch('button.submit', function*() {
  yield* primaryButton();
  yield* submitBehavior();
});

// Input validation generator
function* emailValidation() {
  yield on('input', (event, element: HTMLInputElement) => {
    const isValid = element.value.includes('@'); // element is HTMLInputElement
    toggleClass(element, 'invalid', !isValid);
    attr(element, 'aria-invalid', (!isValid).toString());
  });
  
  yield on('blur', (event, element: HTMLInputElement) => {
    if (!element.value) {
      addClass(element, 'required-error');
    }
  });
}

watch('input[type="email"]', function*() {
  yield* emailValidation();
});
```

### Conditional Logic with Type Safety

```typescript
// Type-safe conditional application
const conditionalStyle = <El extends HTMLElement>(
  condition: boolean, 
  trueFn: ElementFn<El>, 
  falseFn?: ElementFn<El>
): ElementFn<El> => 
  (element: El) => {
    if (condition) {
      trueFn(element);
    } else if (falseFn) {
      falseFn(element);
    }
  };

// Dynamic conditional based on element state
const conditionalOnState = <El extends HTMLElement, T>(
  predicate: (element: El) => T,
  trueFn: (value: T, element: El) => void,
  falseFn?: (element: El) => void
): ElementFn<El> => 
  (element: El) => {
    const result = predicate(element);
    if (result) {
      trueFn(result, element);
    } else if (falseFn) {
      falseFn(element);
    }
  };

// Usage with proper typing
watch('input[type="password"]', conditionalOnState(
  (input: HTMLInputElement) => input.value.length,
  (length: number, input: HTMLInputElement) => {
    const strength = length > 8 ? 'strong' : length > 4 ? 'medium' : 'weak';
    input.setAttribute('data-strength', strength);
  },
  (input: HTMLInputElement) => {
    input.removeAttribute('data-strength');
  }
));
```

### State Management with Generators

```typescript
// State as extension using generator pattern
function createState<T>(initial: T) {
  let value = initial;
  return {
    get: () => value,
    set: (newValue: T) => { value = newValue; },
    update: (fn: (current: T) => T) => { value = fn(value); }
  };
}

// State management with WeakMap for element isolation
const elementStates = new WeakMap<HTMLElement, Map<string, any>>();

function* useState<T>(key: string, initialValue: T) {
  yield (element: HTMLElement) => {
    if (!elementStates.has(element)) {
      elementStates.set(element, new Map());
    }
    
    const states = elementStates.get(element)!;
    if (!states.has(key)) {
      states.set(key, createState(initialValue));
    }
  };
}

function getState<T>(element: HTMLElement, key: string): T {
  const states = elementStates.get(element);
  return states?.get(key)?.get();
}

function setState<T>(element: HTMLElement, key: string, value: T): void {
  const states = elementStates.get(element);
  states?.get(key)?.set(value);
}

function updateState<T>(element: HTMLElement, key: string, updater: (current: T) => T): void {
  const states = elementStates.get(element);
  states?.get(key)?.update(updater);
}

// Usage with generators
watch('.counter', function*() {
  yield* useState('count', 0);
  
  yield (element: HTMLElement) => {
    const count = getState<number>(element, 'count');
    text(element, `Count: ${count}`);
  };
  
  yield on('click', (event, element) => {
    updateState<number>(element, 'count', c => c + 1);
    const newCount = getState<number>(element, 'count');
    text(element, `Count: ${newCount}`);
  });
});
```

## Extensions

### Type-Safe Higher-Order Functions

```typescript
// Type-preserving debounce extension
const debounce = <El extends HTMLElement>(
  ms: number, 
  fn: ElementFn<El>
): ElementFn<El> => {
  const timeouts = new WeakMap<El, number>();
  
  return (element: El) => {
    const existingTimeout = timeouts.get(element);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
    }
    
    const timeout = setTimeout(() => {
      fn(element);
      timeouts.delete(element);
    }, ms);
    
    timeouts.set(element, timeout);
  };
};

// Type-preserving throttle extension  
const throttle = <El extends HTMLElement>(
  ms: number, 
  fn: ElementFn<El>
): ElementFn<El> => {
  const lastRun = new WeakMap<El, number>();
  
  return (element: El) => {
    const now = Date.now();
    const last = lastRun.get(element) || 0;
    
    if (now - last >= ms) {
      fn(element);
      lastRun.set(element, now);
    }
  };
};

// Type-preserving once extension
const once = <El extends HTMLElement>(fn: ElementFn<El>): ElementFn<El> => {
  const executed = new WeakSet<El>();
  
  return (element: El) => {
    if (!executed.has(element)) {
      fn(element);
      executed.add(element);
    }
  };
};

// Usage with preserved types in generators
watch('input[type="search"]', function*() {
  yield debounce(300, 
    on('input', (event, element: HTMLInputElement) => {
      // element is properly typed as HTMLInputElement
      const query = element.value;
      performSearch(query);
    })
  );
});
```

### Animation Extension with Generators

```typescript
// Animation as extension - dual API pattern
function animate<El extends HTMLElement>(
  element: El, 
  keyframes: Keyframe[], 
  options?: KeyframeAnimationOptions
): Animation;
function animate<El extends HTMLElement>(
  keyframes: Keyframe[], 
  options?: KeyframeAnimationOptions
): ElementFn<El, Animation>;
function animate<El extends HTMLElement>(...args: any[]): any {
  if (args.length >= 2 && typeof args[0] === 'object' && 'animate' in args[0]) {
    const [element, keyframes, options] = args;
    return element.animate(keyframes, options);
  } else {
    const [keyframes, options] = args;
    return (element: El) => element.animate(keyframes, options);
  }
}

// Animation presets
function fadeIn<El extends HTMLElement>(duration = 300): ElementFn<El, Animation> {
  return animate([
    { opacity: '0' },
    { opacity: '1' }
  ], { duration, fill: 'forwards' });
}

function fadeOut<El extends HTMLElement>(duration = 300): ElementFn<El, Animation> {
  return animate([
    { opacity: '1' },
    { opacity: '0' }
  ], { duration, fill: 'forwards' });
}

// Generator-based animation sequences  
function* fadeInSequence() {
  yield fadeIn();
  yield addClass('visible');
}

// Usage with generators
watch('.modal', function*() {
  yield* fadeInSequence();
});
```

### Form Extension

```typescript
// Form handling as extension
const value = (val: string): ElementFn => 
  (element) => {
    if (element instanceof HTMLInputElement) {
      element.value = val;
    }
  };

const checked = (isChecked: boolean): ElementFn => 
  (element) => {
    if (element instanceof HTMLInputElement) {
      element.checked = isChecked;
    }
  };

const validate = (validator: (value: string) => boolean): ElementFn => 
  (element) => {
    if (element instanceof HTMLInputElement) {
      const isValid = validator(element.value);
      element.classList.toggle('invalid', !isValid);
    }
  };

// Form composition
const emailInput = sequence(
  attr('type', 'email'),
  attr('required', 'true'),
  validate(value => value.includes('@')),
  on('input', (event) => {
    const input = event.target as HTMLInputElement;
    validate(value => value.includes('@'))(input);
  })
);

watch('input[type="email"]', emailInput);
```

### Observer Extensions

```typescript
// Intersection Observer extension
const onVisible = (handler: (isVisible: boolean) => void): ElementFn => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      handler(entry.isIntersecting);
    });
  });
  
  return (element) => {
    observer.observe(element);
  };
};

// Resize Observer extension
const onResize = (handler: (entry: ResizeObserverEntry) => void): ElementFn => {
  const observer = new ResizeObserver((entries) => {
    entries.forEach(entry => {
      handler(entry);
    });
  });
  
  return (element) => {
    observer.observe(element);
  };
};

// Usage
watch('.lazy-image', sequence(
  onVisible((isVisible) => {
    if (isVisible) {
      attr('src', 'image.jpg');
    }
  }),
  addClass('lazy-loaded')
));
```

## Framework Integration

### React Integration

```typescript
// React hook for watch
import { useEffect } from 'react';

function useWatch(selector: string, fn: ElementFn) {
  useEffect(() => {
    const unwatch = watch(selector, fn);
    return unwatch;
  }, [selector, fn]);
}

// Usage in React component
function MyComponent() {
  useWatch('.dynamic-content', sequence(
    addClass('react-managed'),
    text('Managed by React')
  ));
  
  return <div className="dynamic-content">Hello</div>;
}
```

### Vue Integration

```typescript
// Vue composable
import { onMounted, onUnmounted } from 'vue';

export function useWatch(selector: string, fn: ElementFn) {
  let unwatch: (() => void) | null = null;
  
  onMounted(() => {
    unwatch = watch(selector, fn);
  });
  
  onUnmounted(() => {
    if (unwatch) {
      unwatch();
    }
  });
}

// Usage in Vue component
export default {
  setup() {
    useWatch('.vue-content', sequence(
      addClass('vue-managed'),
      text('Managed by Vue')
    ));
    
    return {};
  }
};
```

### Signal Integration

```typescript
// Signal integration as extension
const createSignal = <T>(initial: T) => {
  let value = initial;
  const subscribers = new Set<() => void>();
  
  return {
    get: () => value,
    set: (newValue: T) => {
      if (value !== newValue) {
        value = newValue;
        subscribers.forEach(fn => fn());
      }
    },
    subscribe: (fn: () => void) => {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }
  };
};

// Signal-aware element function
const reactive = <T>(signal: ReturnType<typeof createSignal<T>>, fn: (value: T) => ElementFn): ElementFn => {
  return (element) => {
    const update = () => fn(signal.get())(element);
    
    // Initial render
    update();
    
    // Subscribe to changes
    signal.subscribe(update);
  };
};

// Usage
const count = createSignal(0);

watch('.counter', sequence(
  reactive(count, (value) => text(`Count: ${value}`)),
  on('click', () => {
    count.set(count.get() + 1);
  })
));
```

### View Transitions Integration

```typescript
// View Transitions as extension
const withViewTransition = (name: string, fn: ElementFn): ElementFn => 
  (element) => {
    if (document.startViewTransition) {
      document.startViewTransition(() => {
        fn(element);
      });
    } else {
      fn(element);
    }
  };

// Usage
watch('.page-content', 
  withViewTransition('page-transition', sequence(
    fadeIn(),
    addClass('visible')
  ))
);
```

### Router Integration

```typescript
// Router integration
const createRouter = () => {
  const routes = new Map<string, () => void>();
  
  return {
    register: (path: string, handler: () => void) => {
      routes.set(path, handler);
    },
    navigate: (path: string) => {
      const handler = routes.get(path);
      if (handler) {
        handler();
      }
      history.pushState(null, '', path);
    },
    init: () => {
      window.addEventListener('popstate', () => {
        const path = location.pathname;
        const handler = routes.get(path);
        if (handler) {
          handler();
        }
      });
    }
  };
};

// Route-aware element function
const onRoute = (path: string, fn: ElementFn): ElementFn => {
  const router = createRouter();
  
  return (element) => {
    router.register(path, () => fn(element));
  };
};

// Usage
watch('.page', onRoute('/home', sequence(
  addClass('active'),
  text('Home Page')
)));
```

## Batching Extension

```typescript
// Batching as extension (user can add if needed)
const createBatcher = () => {
  const queue = new Set<() => void>();
  let scheduled = false;
  
  return {
    add: (fn: () => void) => {
      queue.add(fn);
      if (!scheduled) {
        scheduled = true;
        requestAnimationFrame(() => {
          queue.forEach(fn => fn());
          queue.clear();
          scheduled = false;
        });
      }
    }
  };
};

const batcher = createBatcher();

const batched = (fn: ElementFn): ElementFn => 
  (element) => {
    batcher.add(() => fn(element));
  };

// Usage
watch('.frequently-updated', batched(sequence(
  text('Updated'),
  addClass('fresh')
)));
```

## Performance Characteristics

### Efficient DOM Processing

```typescript
// Single pass through DOM changes
// O(n) where n = number of changed elements
// Each element checked against all selectors once

// Selector matching is optimized by browser's native .matches()
// WeakMap cleanup prevents memory leaks
// No redundant observers or event listeners
```

### Memory Management

```typescript
// Automatic cleanup when selectors are unregistered
// WeakMap/WeakSet for automatic garbage collection
// Single global observer instead of per-element observers
// No memory leaks from abandoned elements
```

## Testing

```typescript
// Testing is straightforward - just test functions
describe('text function', () => {
  it('should set text content', () => {
    const element = document.createElement('div');
    text('Hello World')(element);
    expect(element.textContent).toBe('Hello World');
  });
});

describe('composition', () => {
  it('should compose functions', () => {
    const element = document.createElement('div');
    const composed = sequence(
      text('Hello'),
      addClass('greeting')
    );
    
    composed(element);
    
    expect(element.textContent).toBe('Hello');
    expect(element.classList.contains('greeting')).toBe(true);
  });
});

// Integration testing
describe('watch integration', () => {
  it('should apply functions to matching elements', () => {
    document.body.innerHTML = '<div class="test">Original</div>';
    
    watch('.test', text('Updated'));
    
    // Trigger observer
    const newElement = document.createElement('div');
    newElement.className = 'test';
    document.body.appendChild(newElement);
    
    // Should be processed by observer
    expect(newElement.textContent).toBe('Updated');
  });
});
```

## Migration from v4

```typescript
// v4 style
watch('.button', function*() {
  yield text('Click me');
  yield addClass('primary');
  yield on('click', handler);
});

// v5 style
watch('.button', sequence(
  text('Click me'),
  addClass('primary'),
  on('click', handler)
));

// v4 state
watch('.counter', function*() {
  const count = createState('count', 0);
  yield count.init();
  yield on('click', () => count.update(c => c + 1));
});

// v5 state (as extension)
watch('.counter', withState('count', (count = 0, setCount) => 
  sequence(
    text(`Count: ${count}`),
    on('click', () => setCount(count + 1))
  )
));
```

## Implementation Size

```typescript
// Core implementation is ~100 lines
// Single observer + selector registry
// Function composition utilities
// No dependencies, no build step
// Everything else is extensions
```

## Extension Examples

### Custom DSL

```typescript
// Users can build their own DSL
const $ = {
  text: (content: string) => text(content),
  class: (className: string) => addClass(className),
  style: (prop: string, value: string) => style(prop, value),
  on: (event: string, handler: EventListener) => on(event, handler),
  
  // Combine multiple operations
  setup: (...fns: ElementFn[]) => sequence(...fns)
};

// Usage with custom DSL
watch('.button', $.setup(
  $.text('Click me'),
  $.class('primary'),
  $.style('color', 'blue'),
  $.on('click', () => console.log('clicked'))
));
```

### Reactive Store

```typescript
// Users can integrate any store
const store = createStore({ count: 0 });

watch('.counter', reactive(
  () => store.state.count,
  (count) => text(`Count: ${count}`)
));

// Store updates automatically trigger DOM updates
store.setState({ count: 1 });
```

### Animation Library

```typescript
// Users can integrate any animation library
const gsap = require('gsap');

const gsapAnimate = (props: any, duration: number): ElementFn => 
  (element) => {
    gsap.to(element, { ...props, duration });
  };

watch('.animated', sequence(
  gsapAnimate({ opacity: 1, scale: 1 }, 0.3),
  addClass('visible')
));
```

## Conclusion

Watch v5 achieves the **perfect synthesis** of all previous versions, combining:

### The Best of Each Version

**From v3**: Sophisticated type system and comprehensive features  
**From v4**: Dual API pattern (direct + generator usage)  
**From v5**: Minimal kernel and performance optimizations  
**Plus**: Generator composition and beautiful type flow  

### Key Benefits

1. **Dual API**: Every function works directly AND in generators
2. **Type Safety**: Beautiful type flow from selectors to event handlers
3. **Minimal Kernel**: ~100 lines of core observation code
4. **Generator Composition**: Natural, monadic function composition
5. **Performance**: Single observer, efficient DOM processing
6. **Extensible**: Easy to add any abstraction
7. **Testable**: Pure functions, no magic
8. **Integrable**: Works with any framework or library

### The Breakthrough: Natural Progression

```typescript
// 1. Start simple (direct usage)
const button = document.querySelector('button');
text(button, 'Click me');
addClass(button, 'primary');

// 2. Add interactivity (direct events)
on(button, 'click', (event, element) => {
  element.disabled = true;
});

// 3. Complex behaviors (generators)
watch('button', function*() {
  yield text('Click me');
  yield addClass('primary');
  yield on('click', (event, element) => {
    element.disabled = true;
  });
});

// 4. Reusable patterns (generator composition)
function* buttonBehavior() {
  yield* primaryStyle();
  yield* clickHandling();
}

watch('button', function*() {
  yield* buttonBehavior();
});
```

### Design Philosophy

- **Progressive enhancement**: Start simple, grow complex naturally
- **Type safety first**: Every function preserves and flows types
- **Dual APIs**: Direct usage + generator composition
- **Minimal kernel**: Core does only DOM observation
- **Pure functions**: No side effects, predictable behavior
- **Generator composition**: Monadic, natural function composition
- **Zero magic**: Everything is explicit and transparent

### Why This Works

1. **No learning curve**: Direct functions work like vanilla DOM
2. **Natural progression**: Clear path from simple to complex
3. **Type safety**: Prevents runtime errors, excellent DX
4. **Performance**: Single observer, efficient processing
5. **Composability**: Generators make complex behaviors simple
6. **Extensibility**: Users can build any abstraction
7. **Framework agnostic**: Works with everything

Watch v5 is not just a library - it's the **ideal foundation** for building DOM-based applications. It respects the user's journey from simple DOM manipulation to sophisticated interactive systems, all with the same elegant patterns.

The dual API pattern solves the fundamental tension between simplicity and power, while generators provide the missing piece for natural function composition. Combined with beautiful type safety, this creates the **definitive DOM observation library**.
